import {Codeblock, Code, Pseudocode} from "@/kit/Code"
import {BulletList, EnumList, Item} from "@/kit/Lists"
import {Display, Math} from "@/kit/Math"
import {Heading, P, Par, Section, Subheading, Weak} from "@/kit/Typography"
import {Title} from "@/kit/Elements"
import Image from "@/kit/Image"

export const metadata = {
  title: "Сортировки. Задания",
}

export default function ProblemsetSorting() {
  return (
    <>
      <Title>Сортировки. Задания</Title>

      <Section>
        <Heading>Сортировка выбором</Heading>
        <P>Нарисовать сортировочную сеть для сортировки выбором.</P>
        <P>Оценить сложность, точное количество операций сравнения и обмена.</P>
      </Section>

      <Section>
        <Heading>Сортировка слиянием</Heading>
        <P>Реализовать алгоритм сортировки слиянием.</P>
        <P>
          Если знаете указатели, попробуйте реализовать на C с использованием
          обычных статических массивов и обычных функций. Если не знаете, пишите
          на питоне.
        </P>
        <P>
          Отдельно напишите функцию объединения массивов <Code>merge</Code> и
          функцию самой сортировки <Code>sort</Code>.
        </P>
      </Section>

      <Section>
        <Heading>Цифровая сортировка</Heading>
        <P>
          Реализуйте цифровую сортировку, которая сортирует массив чисел за{" "}
          <Math>O(n \cdot d)</Math>, где <Math>d</Math> -- максимальное
          количество знаков в десятичной записи среди всех чисел.
        </P>
        <P>
          Цифровая сортировка работает как сортировка подсчетом для каждого
          разряда числа отдельно.
        </P>
      </Section>

      <Heading>Правильная сумма</Heading>
      <Section>
        <Par>
          <P>
            На доске сумма нескольких чисел. Эти числа могут быть только{" "}
            <Math>1, 2, 3, \dots, 10</Math>. Поменяйте местами числа так, чтобы
            они шли в порядке возрастания.
          </P>
          <P>
            Например, <Code>2+4+1+2+3</Code> нужно преобразовать в{" "}
            <Code>1+2+2+3+4</Code>
          </P>
        </Par>
        <Par>
          <P>
            <b>Входные данные</b> -- исходный пример, состоящий из чисел и
            знаков <Code>+</Code> между ними
          </P>
          <P>
            <b>Выходные данные</b> -- преобразованный пример
          </P>
        </Par>
      </Section>

      <Section>
        <Heading>Змеиная сортировка</Heading>
        <Par>
          <P>Реализуйте необычный способ превратить массив в змеиный</P>
          <P>
            Массив <Math>a</Math> называется змеиным, если{" "}
            <Math>{`a_i >= a_{i-1}`}</Math> для четных <Math>i</Math> и{" "}
            <Math>{`a_i <= a_{i-1}`}</Math> для нечетных <Math>{`i > 1`}</Math>.
            Индексация здесь с <Math>1</Math>.
          </P>
        </Par>
        <Pseudocode>{`1 1 1 1    ->  1 1 1 1
1 2 2 1    ->  1 2 1 2
1 3 2 2 5  ->  1 5 2 3 2`}</Pseudocode>
      </Section>

      <Par>
        <P>
          <b>Входные данные</b> -- исходный массив из чисел
        </P>
        <P>
          <b>Выходные данные</b> -- змеино отсортированный массив
        </P>
      </Par>

      <Section>
        <Heading>Раздели честно</Heading>
        <Par>
          <P>
            Дан список из <Math>2n</Math> элементов. Мы разделяем этот список на{" "}
            <Math>2</Math> списка с <b>нечетным</b> числом элементов в каждом,
            да так, чтобы модуль разности между медианами этих двух списков был
            минимальным.
          </P>
          <P>Какой минимальный модуль разности может быть?</P>
          <P>
            Медиана массива нечетной длины -- число, которое стоит посередине,
            если массив отсортирован.
          </P>
        </Par>
        <Par>
          <P>
            <b>Входные данные</b> -- исходный массив из чисел длины{" "}
            <Math>2n</Math>
          </P>
          <P>
            <b>Выходные данные</b> -- минимальный модуль разности медиан
          </P>
        </Par>
      </Section>
    </>
  )
}
